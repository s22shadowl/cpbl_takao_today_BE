# .github/workflows/e2e_workflow_health_check.yml

name: E2E 測試：GHA 工作流健康度檢查

on:
  # 允許手動從 GitHub Actions 頁面觸發此 workflow
  workflow_dispatch:

  # 每次推送到 main 分支且 CI/CD 部署完成後觸發
  push:
    branches:
      - main

jobs:
  run-e2e-workflow-test:
    name: 執行 GHA 工作流 E2E 測試
    runs-on: ubuntu-latest
    steps:
      - name: 安裝 flyctl 與 jq
        run: |
          curl -L https://fly.io/install.sh | sh
          echo "/home/runner/.fly/bin" >> $GITHUB_PATH
          sudo apt-get update && sudo apt-get install -y jq

      - name: 步驟 1：擴展並啟動生產環境機器 (Web & Worker)
        # [修改]
        # 原本的 `fly machine list | jq` 流程過於脆弱，
        # 因為 API 對 'stopped' 狀態的機器回傳的 JSON 結構可能不同，導致 jq 解析失敗。
        # 改為使用宣告式的 `fly scale count`，它不關心當前狀態，
        # 而是直接命令平台達成「有 N 台機器在運行」的最終目標，這更為強健。
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          APP_NAME="cpbl-takao-today-be"
          echo "正在確保 web process group 至少有一台機器運行..."
          fly scale count web=1 --app $APP_NAME --yes
          echo "正在確保 worker process group 至少有一台機器運行..."
          fly scale count worker=1 --app $APP_NAME --yes
          echo "Web 與 Worker 機器已啟動。"

      - name: 步驟 2： 等待 Web 服務健康檢查
        run: |
          timeout 180s bash -c ' \
            until curl -s -f https://cpbl-takao-today-be.fly.dev/api/system/health; \
            do \
              echo "Web 服務尚未就緒，等待中..."; \
              sleep 5; \
            done; \
            echo "Web 服務已回報健康！"; \
          ' || (echo "健康檢查在 3 分鐘後超時。" && exit 1)

      - name: 步驟 3： 觸發 E2E 測試任務並取得 Task ID
        id: trigger
        run: |
          API_URL="https://cpbl-takao-today-be.fly.dev/api/system/trigger-e2e-test-task"
          RESPONSE_JSON=$(curl -f -s -X POST -H "X-API-Key: ${{ secrets.PROD_API_KEY }}" $API_URL)
          TASK_ID=$(echo $RESPONSE_JSON | jq -r .task_id)
          echo "E2E 測試任務已觸發，Task ID: $TASK_ID"
          echo "task_id=$TASK_ID" >> $GITHUB_OUTPUT

      - name: 步驟 4 & 5： 監控任務狀態並進行斷言
        if: steps.trigger.outputs.task_id != '' && steps.trigger.outputs.task_id != 'null'
        run: |
          TASK_ID=${{ steps.trigger.outputs.task_id }}
          STATUS_URL="https://cpbl-takao-today-be.fly.dev/api/system/task-status/$TASK_ID"
          TIMEOUT=60
          INTERVAL=5
          ELAPSED=0

          echo "正在監控 Task ID: $TASK_ID..."

          while [ $ELAPSED -lt $TIMEOUT ]; do
            RESPONSE=$(curl -s -w "\n%{http_code}" -H "X-API-Key: ${{ secrets.PROD_API_KEY }}" $STATUS_URL)
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | sed '$d')

            if [ "$HTTP_CODE" -ne 200 ]; then
              echo "輪詢狀態時發生錯誤: HTTP $HTTP_CODE。重試中..."
            else
              STATUS=$(echo $BODY | jq -r .status)
              echo "目前任務狀態: $STATUS (已耗時: ${ELAPSED}s)"

              if [ "$STATUS" == "succeeded" ]; then
                echo "✅ E2E 測試成功！任務已如預期完成。"
                exit 0
              elif [ "$STATUS" == "failed" ]; then
                echo "❌ E2E 測試失敗！任務回報 failed 狀態。"
                exit 1
              fi
            fi

            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done

          echo "❌ E2E 測試失敗！在 ${TIMEOUT} 秒後超時。"
          exit 1

      - name: 步驟 6： 將機器縮減至零 (無論成功或失敗都執行)
        # [修改]
        # 同樣使用 `fly scale count 0` 來將機器數量縮減至零，
        # 讓應用程式回到 scale-to-zero 的閒置狀態。
        if: always()
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          APP_NAME="cpbl-takao-today-be"
          echo "正在將 web 機器數量縮減至 0..."
          fly scale count web=0 --app $APP_NAME --yes
          echo "正在將 worker 機器數量縮減至 0..."
          fly scale count worker=0 --app $APP_NAME --yes
          echo "機器已設定為 scale-to-zero 狀態。"
